package MSDNS;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class DNSHeader {
    private int msgId_, qrCode_, opCode_,
                authoritativeAnswer_, truncation_,
                recursionDesired_, recursionAvailable_,
                reservedSpace_, responseCode_;
    int qdCount_, anCount_, nsCount_, arCount_;

    /**
     * read the header from an input stream
     * @return header
     */
    public static DNSHeader decodeHeader(InputStream inputStream) {
        DNSHeader header = new DNSHeader();
        ByteArrayInputStream byteArrayInputStream = (ByteArrayInputStream) inputStream;

        int mask = 0xf;
        header.msgId_ = DNSMessage.getByteGroup(2, byteArrayInputStream);

        int thirdByte = DNSMessage.getByteGroup(1, byteArrayInputStream);
        header.qrCode_ = DNSMessage.getOneBit(thirdByte, 0);
        header.authoritativeAnswer_ = DNSMessage.getOneBit(thirdByte, 5);
        header.truncation_ = DNSMessage.getOneBit(thirdByte, 6);
        header.recursionDesired_ = DNSMessage.getOneBit(thirdByte, 7);

        thirdByte = thirdByte >> 3;
        header.opCode_ = thirdByte & mask;

        int fourthByte = DNSMessage.getByteGroup(1, byteArrayInputStream);
        header.recursionAvailable_ = DNSMessage.getOneBit(fourthByte, 0);

        header.reservedSpace_ = (fourthByte >> 4) & 0x7;
        header.responseCode_ = fourthByte & mask;

        header.qdCount_ = DNSMessage.getByteGroup(2, byteArrayInputStream);
        header.anCount_ = DNSMessage.getByteGroup(2, byteArrayInputStream);
        header.nsCount_ = DNSMessage.getByteGroup(2, byteArrayInputStream);
        header.arCount_ = DNSMessage.getByteGroup(2, byteArrayInputStream);

        return header;
    }

    /**
     * create the header for the response
     * @return response header
     */
    public static DNSHeader buildHeaderForResponse(DNSMessage request, DNSMessage response) {
        DNSHeader responseHeader = new DNSHeader();

        responseHeader.msgId_ = request.header_.msgId_;
        responseHeader.qrCode_              = 1;
        responseHeader.opCode_              = 0;
        responseHeader.authoritativeAnswer_ = 0;
        responseHeader.truncation_          = 0;
        responseHeader.recursionDesired_    = 1;
        responseHeader.recursionAvailable_  = 1;
        responseHeader.reservedSpace_       = 0;
        responseHeader.responseCode_        = 0;
        responseHeader.qdCount_ = response.questions_.length;
        responseHeader.anCount_ = response.answers_.length;
        responseHeader.nsCount_ = response.authorityRecords_.length;
        responseHeader.arCount_ = response.additionalRecords_.length;

        return responseHeader;
    }

    /**
     * encode the header to bytes to be sent back to the client
     */
    public void writeBytes(OutputStream outputStream) throws IOException {
        outputStream.write(DNSMessage.intToByteArray(msgId_));
        // QR|OPCODE|AA|TC|RD|RA|Z|RCODE = 1|0000|0|0|1|1|000|0000 = 0x8180
        outputStream.write(DNSMessage.intToByteArray(0x8180));
        outputStream.write(DNSMessage.intToByteArray(qdCount_));
        outputStream.write(DNSMessage.intToByteArray(anCount_));
        outputStream.write(DNSMessage.intToByteArray(nsCount_));
        outputStream.write(DNSMessage.intToByteArray(arCount_));
    }

    /**
     * autogenerated by IDE
     * @return a human-readable string version of a header object
     */
    @Override
    public String toString() {
        return "DNSHeader{" + "id=" + msgId_ + ", qr=" + qrCode_ + ", opCode=" +
                opCode_ + ", aa=" + authoritativeAnswer_ + ", tc=" + truncation_ +
                ", rd=" + recursionDesired_ + ", ra=" + recursionAvailable_ +
                ", z=" + reservedSpace_ + ", rCode=" + responseCode_ + ", qdCount=" +
                qdCount_ + ", anCount=" + anCount_ + ", nsCount=" + nsCount_ +
                ", arCount=" + arCount_ + '}';
    }
}
